<!DOCTYPE html>
<html>

<head>
    <title>Κεφάλαιο 4ο</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="icon" href="../images/logo.png">
    <link rel="stylesheet" href="../styles/chapters-style.css">
    <link rel="stylesheet" href="../styles/bootstrap/bootstrap.css">
</head>

<body>
    <header>
        <h1 id="title">Ο Κόσμος της C++</h1>
        <a href="../main_menu.php"><img id="logo" src="../images/logo2.jpg"></a>
        <!--<button id="disconnect">Αποσύνδεση</button>-->
        <div id="menu" class="top-menu">

            <a href="../statistics.php" id="statistics">Στατιστικά</a>
            <a href="../logout.php" id="disconnect">Αποσύνδεση</a>
        </div>
    </header>

    <!--
    <nav id="nav-menu">
        <ul id="chapter-menu">
            <li><a id="menu-chapter1" href="../chapter1/chapter1.html">Κεφάλαιο 1</a></li>
            <li><a id="menu-chapter2" href="../chapter2/chapter2.html">Κεφάλαιο 2</a></li>
            <li><a id="menu-chapter3" href="../chapter3/chapter3.html">Κεφάλαιο 3</a></li>
            <li><a id="menu-chapter5" href="../chapter5/chapter5.html">Κεφάλαιο 5</a></li>
        </ul>
    </nav>
-->

    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a class="nav-link" href="../chapter1/chapter1.html">Κεφάλαιο 1</a>
                </li>
            </ul>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a class="nav-link" href="../chapter2/chapter2.html">Κεφάλαιο 2</a>
                </li>
            </ul>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a class="nav-link" href="../chapter3/chapter3.html">Κεφάλαιο 3</a>
                </li>
            </ul>
            <ul class="navbar-nav">
                <li class="nav-item" id="current_chapter">
                    <a class="nav-link disabled">Κεφάλαιο 4</a>
                </li>
            </ul>
            <ul class="navbar-nav">
                <li class="nav-item">
                  <a class="nav-link" href="../chapter5/chapter5.html">Κεφάλαιο 5</a>
                </li>
              </ul>
        </div>
    </nav>

    <aside id="nav-bar">
        <h2>Πίνακας Περιεχομένων</h2>
        <ol>
            <li><a href="#section1">Περι συναρτήσεων</a></li>
            <li><a href="#section2">Pass by value</a></li>
            <li><a href="#section3">Pass by reference</a></li>
            <li><a href="#section4">Pass by pointer</a></li>
            <li><a href="#section5">Προκαθορισμένες τιμές</a></li>
            <li><a href="#section6">Πολυμορφισμός</a></li>
        </ol>
    </aside>

    <main>
        <div class="container">
            <div class="row">
                <div class="col-lg-auto col-md-auto col-sm-auto">
                    <h1>Κεφάλαιο 4ο - Συναρτήσεις</h1>

                    <section id="section1">
                        <h2>1&rpar; Περι συναρτήσεων</h2>

                        <p>
                            Στην C++, μια συνάρτηση είναι ένα τμήμα προγράμματος που εκτελεί μια συγκεκριμένη εργασία
                            και μπορεί να
                            καλείται από αλλού στο πρόγραμμα.
                            Συνήθως, μια συνάρτηση αποτελείται από τον ορισμό της στο πάνω μέρος συνήθως του
                            προγράμματος όπου και
                            ορίζετε με όνομα, τύπο δεδομένων επιστροφής και ορίσματα,
                            παρακάτω θα υπάρχει το σώμα(με τις εντολές που εκτελεί) της συνάρτησης. Από την άλλη μπορεί
                            ο ορισμός
                            της και το σώμα να σε ένα σημείο.

                        </p>
                        <strong>
                            <p>
                                Ορισμός συνάρτησης add πρώτα και μετα το σώμα της:
                            </p>
                        </strong>
                        <pre>
                <code>
                   int add(int a, int b);//πάνω μέρος προγράμματος
                   
                   //...και άλλοι ορισμοί άλλων συναρτήσεων αν υπάρχουν...

                   // Δήλωση συνάρτησης με όνομα add πριν τη main()
                   int add(int a, int b) {
                       return a + b;
                   }

                    </code>
                </pre>

                        <strong>
                            <p>
                                Δήλωση με σώμα συνάρτησης χωρίς ορισμό στο πάνω μέρος:
                            </p>
                        </strong>

                        </p>
                        <pre>
                <code>
                 
                   // Δήλωση συνάρτησης με όνομα add πριν τη main()
                   int add(int a, int b) {
                       return a + b;
                   }

                    </code>
                </pre>

                        <p>
                            Στα πάνω αποσπάσματα βλέπουμε πως την συνάρτηση την λένε 'add' , πως ο τύπος δεδομένων
                            επιστροφής είναι int , δηλάδη πως το a+b στο return θα είναι
                            int. Τέλος, ανάμεσα στις περενθέσεις βάζουμε τα ορίσματα της συνάρτησης τα οποία είναι
                            μεταβλητές με τιμές από κάποια εξωτερική συνάρτηση (μπορεί να είναι
                            και η main()) θα την καλεί. Αν μια συνάρτηση δεν επιστρέφει κάτι τότε την ονομάζουμε
                            διαδικάσία και ο τύπος που επιστρέφει θα έιναι void.
                            Αντίστοιχα, αν δεν έχει ορίσματα μια συνάρτηση π.χ. int func() , τότε είτε αφήνουμε τις
                            παρενθέσεις κενές όπως στο παράδειγμα πριν είτε γράφουμε void,
                            δηλαδή , int func(void)
                        </p>

                        <p>
                            Ένα παράδειγμα σε πρόγραμμα που καλεί μια συνάρτηση:
                        </p>
                        <pre>
                <code>
                    #include &lt;iostream&gt;
            
                    // Δήλωση συνάρτησης με όνομα add
                    int add(int a, int b) {
                        return a + b;
                    }
            
                    int main() {
                        int result = add(5, 3);
                        std::cout &lt;&lt; "Αποτέλεσμα: " &lt;&lt; result &lt;&lt; std::endl;
                        return 0;
                    }
                </code>
            </pre>

                        <p>
                            Η main() καλεί την add() με ορίσματα τις ακέρειες τιμές 5 και 3 με το αποτέλεσμα να
                            εκχωρηθεί στη μεταβλητή result.
                            Οι τιμές από την main() εκχωρούνται στα ορίσματα a,b της συνάρτησης. Γίνετε πρόσθεση των a,
                            b δηλαδή των 5,3 και τελικά επιστρέφεται το άθροισμα 5+3=8
                            πίσω στην main() στην μεταβλητή result (int όπως και ο τύπος που επιστρέφει η add()).
                            Στό τέλος το result(η τιμή 8) εμφανίζετε στην οθόνη.
                        </p>

                    </section>

                    <section id="section2">
                        <h2>2&rpar; Pass by value</h2>

                        <p>
                            Στην περίπτωση αυτή στα ορίσματα μιας συνάρτησης (τοπικές μεταβλητές) αντιγράφονται οι τιμές
                            μόνο(by value) των αρχικών μεταβλητών
                            της συνάρτησης που την κάλεσε και η συνάρτηση λειτουργεί πάνω στις τοπικές
                            μεταβλητές/ορίσματα μόνο.
                            Οποιαδήποτε αλλαγή δεν επηρεάζει τις αρχικές τιμές των μεταβλητών της συνάτησης που την
                            κάλεσε.
                            Το παρακάτω παράδειγμα είναι παρόμοιο με αυτά πριν που είχαμε pass by value στις
                            συναρτήσεις.
                        </p>

                        <p>
                            Παράδειγμα:
                        </p>

                        <pre>
                            <code>
                            #include &lt;iostream&gt;
                    
                            // Συνάρτηση που δέχεται δύο ακέραιους με την με "pass by value"
                            void modifyValue(int x) {
                                x = 10;  // Αλλαγή της τιμής του x
                            }
                    
                            int main() {
                                int value = 5;
                                std::cout &lt;&lt; "Τιμή value: " &lt;&lt; value &lt;&lt; std::endl;//πριν τη συνάρτηση
                                modifyValue(value);
                                std::cout &lt;&lt; "Τιμή value: " &lt;&lt; value &lt;&lt; std::endl;//μετά τη χρήση της
                                return 0;
                            }
                        </code>
                    </pre>

                        <p>
                            Στο παράδειγμα η μεταβλητή value έχει τιμή 5 , τύπου int.
                            Στην πρώτη εμφάνιση της στην οθόνη βλέπουμε το μήνυμα: "Τιμή value: 5".
                            Μετά καλείτε η modifyValue(value); με το value ως όρισμα με την τιμή 5.
                            Αυτή η τιμή (μόνο) εκχωρείτε στηη τοπική μεταβλητή x.
                            Μέσα στην συνάρτηση η x αλλάζει σε 10.
                            Στο τέλος μετά την εκτέλεση της συνάρτησης στην οθόνη εμφανίζεται:"Τιμή value: 5" ξανά
                            εφόσον μόνο η τοπική μεταβλητή x άλλαξε, η value δεν άλλαξε
                        </p>


                    </section>

                    <section id="section3">
                        <h2>3&rpar; Pass by reference</h2>

                        <p>
                            Στην περίπτωση αυτή τα ορίσματα μιας συνάρτησης (τοπικές μεταβλητές) είναι αναφορές στις
                            μεταβλητές της συνάρτησης που την κάλεσε, αυτό σημαίνει πως τα ορίσματα της συνάρτησης είναι
                            συνώνυμα των μεταβλητών της συνάρτησης που την κάλεσε (ίδια θέση μνήμης , με δύο ονόματα).
                            Οποιαδήποτε αλλαγή των αναφορών, επηρεάζει τις αρχικές τιμές των
                            μεταβλητών της συνάτησης που την κάλεσε.

                        </p>

                        <p>
                            Παράδειγμα:
                        </p>

                        <pre><code>
                            #include &lt;iostream&gt;
                    
                            // Συνάρτηση που δέχεται δύο ακέραιους με την τεχνική "pass by reference"
                            void modifyValue(int &x) {
                                x = 10;  // Αλλαγή της τιμής του x
                            }
                    
                            int main() {
                                int value = 5;
                                std::cout &lt;&lt; "Τιμή value: " &lt;&lt; value &lt;&lt; std::endl;
                                modifyValue(value);
                                std::cout &lt;&lt; "Τιμή value: " &lt;&lt; value &lt;&lt; std::endl;
                                return 0;
                            }
                        </code></pre>

                        <p>
                            Στο παράδειγμα η μεταβλητή value έχει τιμή 5 , τύπου int.
                            Στην πρώτη εμφάνιση της στην οθόνη βλέπουμε το μήνυμα: "Τιμή value: 5".
                            Μετά καλείτε η modifyValue(value); με το value ως όρισμα με την τιμή 5.
                            Κατά το κάλεσμα της συνάρτησης δημιουργείτε μία αναφορά στο value (με ίδια θέση μνήμης αλλά
                            διαφορετικό όνομα).
                            Μέσα στην συνάρτηση η x αλλάζει σε 10 αλλάζοντας και το value αντίστοιχα.
                            Στο τέλος μετά την εκτέλεση της συνάρτησης στην οθόνη εμφανίζεται:"Τιμή value: 10" που είναι
                            και το αναμενόμενο.
                        </p>
                    </section>

                    <section id="section4">
                        <h2>4&rpar; Pass by pointer</h2>

                        <p>
                            Στην περίπτωση αυτή τα ορίσματα μιας συνάρτησης (τοπικές μεταβλητές) είναι δείκτες στις
                            μεταβλητές της συνάρτησης που την κάλεσε, αυτό σημαίνει πως τα ορίσματα της συνάρτησης
                            παίρνουν ως
                            τιμές τις διευθύνσεις των μεταβλητών από την συνάρτηση που κάλεσε.
                            Οποιαδήποτε αλλαγή στα περιεχόμενα εκείνων των διευθύνσεων, επηρεάζει τις αρχικές τιμές των
                            μεταβλητών της συνάτησης που την κάλεσε.
                        </p>

                        <p>
                            Παράδειγμα:
                        </p>

                        <pre><code>
                            #include &lt;iostream&gt;
                    
                            // Συνάρτηση που δέχεται έναν δείκτη σε ακέραιο
                            void modifyValue(int *ptr) {
                                *ptr = 10;  // Αλλαγή της τιμής του που δείχνει ο δείκτης
                            }
                    
                            int main() {
                                int value = 5;
                                std::cout &lt;&lt; "Τιμή value: " &lt;&lt; value &lt;&lt; std::endl;
                                modifyValue(&amp;value);
                                std::cout &lt;&lt; "Τιμή value: " &lt;&lt; value &lt;&lt; std::endl;
                                return 0;
                            }
                        </code></pre>

                        <p>
                            Στο παράδειγμα η μεταβλητή value έχει τιμή 5 , τύπου int.
                            Στην πρώτη εμφάνιση της στην οθόνη βλέπουμε το μήνυμα: "Τιμή value: 5".
                            Μετά καλείτε η modifyValue(&amp;value); με τη διευθύνση του value ως τιμή όρισμα.
                            Κατά το κάλεσμα της συνάρτησης στον δείκτη int* ptr εκχωρείτε αυτή η διευθύνση ως τιμή.
                            Μέσα στην συνάρτηση το περιεχόμενο του ptr (*ptr) αλλάζει σε 10 αλλάζοντας και το value
                            αντίστοιχα
                            εφόσον βασικά το ptr δείχνει στην διευθύνση του value έχοντας πρόσβαση έτσι στο περιεχόμενο
                            του ακέραιου.
                            Στο τέλος, μετά την εκτέλεση της συνάρτησης στην οθόνη εμφανίζεται:"Τιμή value: 10" όπως και
                            με την αναφορά.
                        </p>
                    </section>

                    <section id="section5">
                        <h2>5&rpar; Προκαθορισμένες τιμές</h2>

                        <p>
                            Στη C++, μπορείτε να ορίσετε προκαθορισμένες(default) τιμές για κάποια (ή όλα)ορίσματα
                            συναρτήσεων.
                            Αυτό μας επιτρέπει να καλέσουμε τη συνάρτηση χωρίς να δώσουμε τιμές για αυτά τα ορίσματα,
                            αφήνοντας τα να πάρουν τις προκαθορισμένες τιμές.
                        </p>

                        <p>
                            Παράδειγμα συνάρτησης με προκαθορισμένες τιμές στα ορίσματα και χρήση της:
                        </p>

                        <pre>
                            <code>
                            #include &lt;iostream&gt;

                                // Συνάρτηση που πραγματοποιεί πολλαπλασιασμό δύο αριθμών με προκαθορισμένες τιμές
                                int multiply(int x = 2, int y = 3) {
                                    return x * y;
                                }
                                    
                                int main() {
                                    int result1 = multiply(); // Προκαθορισμένες τιμές: x = 2, y = 3
                                    int result2 = multiply(4); // Καθορισμένη τιμή x = 4, προκαθορισμένη τιμή y = 3
                                    int result3 = multiply(4, 5); // Καθορισμένες τιμές: x = 4, y = 5
                                    
                                    std::cout &lt;&lt; "Αποτέλεσμα 1: " &lt;&lt; result1 &lt;&lt; std::endl;
                                    std::cout &lt;&lt; "Αποτέλεσμα 2: " &lt;&lt; result2 &lt;&lt; std::endl;
                                    std::cout &lt;&lt; "Αποτέλεσμα 3: " &lt;&lt; result3 &lt;&lt; std::endl;
                                    
                                    return 0;
                                }
                            </code>
                         </pre>

                         <p>
                            Σε αυτό το παράδειγμα, η συνάρτηση multiply πραγματοποιεί πολλαπλασιασμό δύο ακεραίων αριθμών x και y. 
                            Οι προκαθορισμένες τιμές για τα x και y είναι 2 και 3 αντίστοιχα. 
                            Όταν δίνουμε ορίσματα στη συνάρτηση, αυτά αντικαθιστούν τις προκαθορισμένες τιμές.
                            Αν δεν δώσουμε τιμές για κανένα όρισμα(1η κλίση συνάρτησης) τότε τα ορίσματα παίρνουν τις προκαθορισμένες.
                            Αν από την άλλη εμείς καθορίσουμε κάποια τιμή(2η κλίση συνάρτησης) ή όλες(3η κλίση) τότε αυτές θα πάρουν οι τοπικές μεταβλητές
                            αγνοώντας εντελώς τις προκαθορισμένες.
                         </p>
                    </section>

                    <section id="section6">
                        <h2>6&rpar; Πολυμορφισμός συναρτήσεων</h2>

                        <p>
                          Με την έννοια αυτή όταν μιλάμε για απλές συναρτήσεις, ενννοόυμε την ιδιότητα που έχουν οι συναρήσεις 
                          να μπορούν να έχουν 'αντίγραφα' του εαυτού τους απλά με άλλα ορίσματα (ίδιο όνομα συνάρτησης).
                          Για παράδειγμα: int add(int a, int b) και double add(double a, double b).
                          Μπορούμε να τις έχουμε και τις δύο στο ίδιο πρόγραμμα χωρίς προβλήματα, εφόσον ο μεταγλωττιστής μπορεί να καταλάβει πολλαπλασιασμό
                          καλούμε κάθε φορά ανάλογα με τους τύπους των ορισμάτων (δηλαδή ανάλογα με τις τιμές κατά το κάλεσμα).
                          Σε αυτές το μόνο που θα είναι ίδιο είναι το όνομα, το σώμα τους θα διαφέρει(μαζί με τα ορίσματα).
                        </p>

                        <p>
                            Παράδειγμα:
                        </p>

                        <pre>
                            <code>
                                // συνάρτηση που προσθέτει δύο ακεραίους (1)
                                int add(int a, int b) {
                                    return a + b;
                                }

                                // συνάρτηση που προσθέτει δύο double (2)
                                double add(double a, double b) {
                                    return a + b;
                                }

                                int main() {
                                    int integerA = 5, integerB = 3;
                                    double doubleA = 2.5, doubleB = 1.2;

   
                                    int intResult = add(integerA, integerB);
                                    double doubleResult = add(doubleA, doubleB);

                                    // Εμφανίζουμε τα αποτελέσματα από τις μεταβλητές
                                    std::cout &lt;&lt; "Αποτέλεσμα πρόσθεσης ακεραίων: " &lt;&lt; intResult &lt;&lt; std::endl;
                                    std::cout &lt;&lt; "Αποτέλεσμα πρόσθεσης double: " &lt;&lt; doubleResult &lt;&lt; std::endl;

                                    return 0;
                                }
                            </code>
                        </pre>

                        <p>
                            Σε αυτό το παράδειγμα στο πρώτο κάλεσμα της add() καλείτε αυτή με τα ορίσματα ακεραίων, η πρώτη δήλωση της (1).
                            Αυτό γίνετε εφόσον οι μεταβλητές integerA, integerB είναι τύπου int.
                            Στο επόμενο κάλεσμα καλείτε η add() με ορίσματα double, δηλαδή με την δεύτερη δήλωση της (2), εκτελόντας εκείνο το σώμα.
                            Αντίστοιχα, αυτό συμβαίνει εφόσον παίρνει στα ορίσματα τις μεταβλητές doubleA, doubleB τύπου double.
                            Κατά την εμφάνιση στην οθόνη πρώτα εμφανίζετε: "Αποτέλεσμα πρόσθεσης ακεραίων: 8"
                            και μετά "Αποτέλεσμα πρόσθεσης ακεραίων: 3.7"
                        </p>
                    </section>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <!--
        <ul id="chapter-end-menu">
            <li><a href="../chapter3/chapter3.html">&larr; Προηγούμενο Κεφάλαιο</a></li>
            <li><a href="../main_menu.php">Αρχικό Μενού</a></li>
            <li><a href="../chapter5/chapter5.html">Επόμενο Κεφάλαιο &rarr;</a></li>
        </ul>
    -->

        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <div class="container collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav mr-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../chapter3/chapter3.html">Προηγούμενο Κεφάλαιο</a>
                    </li>
                </ul>
                <ul class="navbar-nav mx-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../main_menu.php">Αρχικό Μενού</a>
                    </li>
                </ul>
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../chapter5/chapter5.html">Επόμενο Κεφάλαιο</a>
                        
                    </li>
                </ul>
            </div>
        </nav>
    </footer>


    <script src="../javascript/disconnect-button.js" type="text/javascript"></script>
    <script src="../javascript/bootstrap-js/bootstrap.js" type="text/javascript"></script>

</body>

</html>