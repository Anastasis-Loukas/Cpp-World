<!DOCTYPE html>
<html>

<head>
    <title>Κεφάλαιο 5ο</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="icon" href="../images/logo.png">

    <link rel="stylesheet" href="../styles/chapters-style.css">
    <link rel="stylesheet" href="../styles/chapter5-style.css">
    <link rel="stylesheet" href="../styles/bootstrap/bootstrap.css">
</head>

<body>
    <header>
        <h1 id="title">Ο Κόσμος της C++</h1>
        <a href="../main_menu.php"><img id="logo" src="../images/logo2.jpg"></a>
        <!-- <button id="disconnect">Αποσύνδεση</button>-->
        <div id="menu" class="top-menu">

            <a href="../statistics.php" id="statistics">Στατιστικά</a>
            <a href="../logout.php" id="disconnect">Αποσύνδεση</a>
        </div>
    </header>

    <!--
        <nav id="nav-menu">
            <ul id="chapter-menu">
                <li><a id="menu-chapter1" href="../chapter1/chapter1.html">Κεφάλαιο 1</a></li>
                <li><a id="menu-chapter2" href="../chapter2/chapter2.html">Κεφάλαιο 2</a></li>
                <li><a id="menu-chapter3" href="../chapter3/chapter3.html">Κεφάλαιο 3</a></li>
                <li><a id="menu-chapter4" href="../chapter4/chapter4.html">Κεφάλαιο 4</a></li>
            </ul>
        </nav>
    -->

    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a class="nav-link" href="../chapter1/chapter1.html">Κεφάλαιο 1</a>
                </li>
            </ul>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a class="nav-link" href="../chapter2/chapter2.html">Κεφάλαιο 2</a>
                </li>
            </ul>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a class="nav-link" href="../chapter3/chapter3.html">Κεφάλαιο 3</a>
                </li>
            </ul>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a class="nav-link" href="../chapter4/chapter4.html">Κεφάλαιο 4</a>
                </li>
            </ul>
            <ul class="navbar-nav">
                <li class="nav-item" id="current_chapter">
                    <a class="nav-link disabled">Κεφάλαιο 5</a>
                </li>
            </ul>
        </div>
    </nav>

    <aside id="nav-bar">
        <h2>Πίνακας Περιεχομένων</h2>
        <ol>
            <li><a href="#section1">Περι κλάσεων</a></li>
            <li><a href="#section2">Κατασκευαστές</a></li>
            <li><a href="#section3">Κατασκευαστής αντιγράφου</a></li>
            <li><a href="#section4">Καταστροφέας</a></li>
            <li><a href="#section5">Υπερφόρτωση τελεστών</a></li>
            <li><a href="#section6">Κληρονομικότητα</a></li>
            <li><a href="#section7">Πολυμορφισμός κλάσεων</a></li>
        </ol>
    </aside>

    <main>
        <div class="container">
            <div class="row">
                <div class="col-lg-auto col-md-auto col-sm-auto">
                    <h1>Κεφάλαιο 5ο - Κλάσεις</h1>

                    <section id="section1">
                        <h2>1&rpar; Περι κλάσεων</h2>

                        <p>
                            Στην C++, οι κλάσεις είναι ένας τρόπος να ορίσουμε νέους τύπους δεδομένων. Μια κλάση είναι
                            ένα προτύπων για τη δημιουργία αντικειμένων
                            (αντικείμενα είναι τα πραγματικά αντίτυπα της κλάσης).Αρχικά έχουμε την λέξη-κλειδι
                            <strong>class</strong> και στα δεξιά το όνομα της κλάσης.
                            Μπορεί να περιέχει δεδομένα μέλη (μεταβλητές) και συναρτήσεις μέλη (μεθόδους) που
                            λειτουργούν πάνω σε αυτά τα δεδομένα.
                            Μια κλάση επίσης καθορίζει τη δομή και τη συμπεριφορά των αντικειμένων της.
                            Τα δεδομένα μέλη και οι μέθοδοι μιας κλάσης υπάγονται πάντα κάτω από λέξεις-κλειδιά/ετικέτες
                            ελέγχου πρόσβασης (permission labels).
                            Tέτοιες ετικέτες υπάρχουν τρεις private: , protected: και public: (οι ':' χρειάζονται).

                        </p>

                        <p>
                            Πιο συγκεκριμένα:
                        </p>

                        <ul>
                            <li>Τα <strong>ιδιωτικά (private)</strong> μέλη είναι προβάσιμα μόνο από άλλα μέλη στην ίδια
                                κλάση ή από τις φιλικές (friend) κλάσεις.</li>
                        </ul>
                        <ul>
                            <li>Τα <strong>προστατευόμενα (protected)</strong> μέλη είναι προσβάσιμα από μέλη της ίδιας
                                κλάσεις και των φιλικών κλάσεων.
                                Επιπλέον δε, είναι προσβάσιμα από τις παράγωγες (derived) κλάσεις.
                            </li>

                        </ul>
                        <ul>
                            <li>Τα <strong>δημόσια (public) </strong> μέλη είναι προσβάσιμα από οπουδήποτε η κλάση είναι
                                ορατή. </li>
                        </ul>

                        <p>
                            Γενικά έτσι είναι ένας ορισμός κλάσης:
                        </p>

                        <pre>
                            <code>
                                class class_name {
                                    public:
                                    // Δημόσιες μεταβλητές και συναρτήσεις
                                    private:
                                    // Ιδιωτικές μεταβλητές και συναρτήσεις
                                    protected:
                                    //Προστατευμένες μεταβλητές και συναρτήσεις
                                    };
                            </code>
                        </pre>

                        <p>
                            Συνήθως τα δεδομένα μέλη είναι <strong>private</strong> ή <strong>protected</strong> ενώ οι
                            μέθοδοι <strong>public</strong>.
                        </p>

                        <p>
                            Συνεπώς για αλλαγές στις τιμές των δεδομένων μελών χρησιμοποιούνται κανονικές μέθοδοι και
                            ειδικές μέθοδοι που δημιουργούνται
                            για τον σκοπό της αρχικοποίησης και αλλαγής των δεδομένων μελών. Αυτές τις μεθόδους τις
                            ονομάζουμε setters (πχ set_variable()).
                            Αντίστοιχα υπάρχουν και μέθοδοι με το όνομα getters(get_variable()) με τους οποίους μπορούμε
                            να ανακτήσουμε τις τιμές δεδομένων μελών
                            αντικειμένων κλάσης.Κάθε δεδομένο μέλος(μεταβλητή) έχει ένα setter και ένα getter με
                            αντίστοιχο όνομα.
                        </p>


                    </section>

                    <section id="section2">
                        <h2>2&rpar; Κατασκευαστές</h2>

                        <p>
                            Ο κατασκευαστής είναι μια ειδική μέθοδος που χρησιμοποιείται για τη δημιουργία αντικειμένων
                            της κλάσης.
                            Καλείται όταν δημιουργείται ένα νέο αντικείμενο και ρυθμίζει τα αρχικά του
                            χαρακτηριστικά/δεδομένα μέλη.
                            Στην ενότητα αυτή θα μιλήσουμε για δύο ειδών κατασκευαστών, τους default και τους
                            'απλους'.

                        </p>

                        <p>
                            Πιο συγκεκριμένα:
                        </p>

                        <ul>
                            <li><strong>Default</strong> είναι οι κατασκευαστές που αρχικοποιούν τα δεδομένα
                                μέλη/μεταβλητές ενός αντικειμένου σε κάποιες προκαθορισμένες
                                τιμές, όπως την τιμή 0 για αριθμητικές μεταβλητές και "Ν/Α"(not available) για strings.
                                Δεν έχει ορίσματα και όταν δημιουργείτε ένα αντικείμενο μιας κλάσης ούτε στο αντικείμενο
                                δεν βάζουμε παρενθέσεις με
                                τιμές για τα ορίσματα.
                                Ο ορισμός της είναι:

                            </li>
                            <pre>
                            <code>

                                class MyClass { 
                                    private:
                                        int myVar;
                                    public:
                                        MyClass() {//δεν έχει ορίσματα
                                            //εκχώρηση προκαθορισμένων τιμών σε δεδομένα μέλη
                                            myVar = 0;
                                        }
                                    };
                            </code>
                        </pre>
                            <p>
                                Παράδειγμα δημιουργείας αντικειμένου με default κατασκευαστή:
                            </p>
                            <pre>
                            <code>
                               myClass obj;
                            </code>
                        </pre>

                            <p>
                                Καλείτε ο default Κατασκευαστής αυτόματα και δίνει την τιμή 0 στο myVar.
                            </p>


                        </ul>

                        <ul>
                            <li><strong>Απλοί</strong> είναι οι κατασκευαστές που αρχικοποιούν τα δεδομένα
                                μέλη/μεταβλητές ενός αντικειμένου από μεταβλητές/απλές τιμές στο σημείο που δηλώθηκε το
                                αντικέιμενο κλάσης και κλήθηκε
                                ο κατασκευαστής.Αυτές οι τιμές εισέρχονται σε παρενθέσεις στα δεξιά του ονμόματος του
                                αντικειμένου σαν να καλούμε μια
                                κανονική συνάρτηση.Με αυτά ορίζονται και οι τιμές των δεδομένων μελών τιυ αντικειμένου.
                                Ο ορισμός της είναι:

                            </li>
                            <pre>
                            <code>
                                class MyClass { 
                                    private:
                                        int myVar;
                                    public:
                                        class_name(int x){//το όρισμα x μπορεί να έχει ίδιο όνομα με το δεδομένο μέλος myVar
                                            myVar = x; 
                                        }
                                    };
                         
                               
                            </code>
                        </pre>

                            <p>
                                Αν έχει το ίδιο όνομα τότε για να τα διαφοροποιήσουμε και να μην υπάρχξουν λάθη
                                χρησιμοποιούμε τον δείκτη(pointer) this.
                                Αυτός είναι ένας δείκτης στο ίδιο το αντικείμενο και *this είναι το ίδιο το αντικείμενο.
                            </p>
                            <pre>
                            <code>
                                class MyClass { 
                                    private:
                                        int myVar;
                                    public:
                                        class_name(int myVar){
                                            this->myVar = myVar; //στα αριστερά έχουμε την μεταβλητή του αντικειμένου και στα δεξιά το myVar είναι
                                            //η μεταβλητή από την δήλωση του αντικειμένου στο πρόγραμμα με κάποια τιμή
                                        }
                                    };
                         
                               
                            </code>
                        </pre>
                            <p>
                                Παράδειγμα δημιουργείας αντικειμένου με απλό κατασκευαστή:
                            </p>
                            <pre>
                            <code>
                                int myVar=5;//αυτή η μεταβλητή δεν χρειάζετε να έχει το ίδιο όνομα με το όρισμα ή/και το δεδομένο
                                //μέλος της κλάσης, θα μπορούσαμε να είχαμε βάλει και 'καρφωτά' την τιμή 5.
                                myClass obj(myVar);
                            </code>
                        </pre>

                            <p>
                                Καλείτε ο απλός Κατασκευαστής αυτόματα και δίνει την τιμή 5 στο myVar.
                                Οι δύο τρόποι απλών κατασκευαστών είναι ισοδύναμοι αλλά μόνο ένας θα υπάρχει μέσα στην
                                κλάση.
                            </p>

                    </section>

                    <section id="section3">
                        <h2>3&rpar; Κατασκευαστής αντιγράφου</h2>

                        <p>
                            Ο κατασκευαστής αντιγραφής(copy constructor) είναι μια ειδική μέθοδος που χρησιμοποιείται
                            για τη δημιουργία ενός αντιγράφου ενός αντικειμένου.
                            Χρησιμοποιείται για την αποφυγή σφαλμάτων αντιγραφής αντικειμένων με δυναμική δέσμευση
                            μνήμης.
                        </p>

                        <p>
                            Στα ορίσματα αυτού αντί για μεταβλητές υπάρχει μια αναφορά σε ένα άλλο αντικείμενο της ίδια
                            κλάσης το οποίο και θέλουμς να αντιγράψουμε στο νέο αντικείμενο που δηλώνουμε. Η αναφορά θα πρέπει να είναι const γιατί δεν
                            θέλουμε να αλλάξει το αντικείμενο/αναφορά.

                        </p>

                        <p>Παράδειγμα:</p>

                        <pre>
                            <code>
                                class MyClass {
                                    public:
                                        int myVar;
                                        MyClass(const MyClass& other) {//σταθερή αναφορά σε αντικείμενο του προγράμματος που υπάρχει ήδη, 
                                            //με όνομα ορίσματος other εδώ
                                            myVar = other.myVar;//αντιγραφή των δεδομένων στο νέο αντικείμενο
                                        }
                                    };
                            </code>
                        </pre>

                        <p>
                            Δημιουργείας αντικειμένου με κατασκευαστή αντιγράφου με δύο ισοδύναμους τρόπους.
                        </p>
                        <ul>
                            <li>1ος τρόπος: </li> 
                            <pre>
                                <code>
                                    class MyClass {
                                        private:
                                            int myVar;
                                        public:
                                            MyClass() {
                                                myVar = 0;
                                            }
                                            MyClass(const MyClass& other) {
                                                myVar = other.myVar;
                                            }
                                        };
    
                                        int main() {
                                            myClass ob1;
                                            myClass ob2 = ob1; 
                                            return 0; 
                                    }
                                </code>
                            </pre>

                            <p>
                                Εδώ με αυτή ακριβώς τη σύνταξη γίνετε η αντιγραφή του ob1 στο ob2 αφού πρώτα δημιουργειθεί το ob1 με τον 
                                default κατασκευαστή.Χρειάζετε μπροστά το όνομα της συνάρτησης εφόσον αν δεν υπήρχε θα γινόταν χρήση του τελεστή εκχώρησης('=') κάτι που
                                για να γίνει σε δική μας κλάση θέλει την υπερφόρτωση του.Για την υπερφόρτωση τελεστών θα μιλήσουμε στη συνέχεια.
                            </p>
                                

                           
                        </ul>
                        <ul>
                            <li>2ος τρόπος:</li>
                            <pre>
                                <code>
                                    class MyClass {
                                        private:
                                            int myVar;
                                        public:
                                            MyClass() {
                                                myVar = 0;
                                            }
                                            MyClass(const MyClass& other) {
                                                myVar = other.myVar;
                                            }
                                        };
    
                                        int main() {
                                            myClass ob1;
                                            myClass ob2(ob1);
                                            return 0; 
                                    }
                                </code>
                            </pre>

                            <p>
                                Εδώ επίσης καλείτε ο κατασκευαστής αντιγράφου αντιγράφοντας το ob1 που υπάρχει στο ob2.
                                Με αυτόν τον τρόπο φαίνετε να χρησιμοποιείτε ακριβώς o κατασκευαστής αντιγράφου που ορίζετε στην κλάση,
                                δηλαδή κάλεσμα κατασκευαστή με αντικείμενο ως όρισμα(που θα έχει αναφορά του μέσα στην μέθοδο).
                            </p>
                                
                        </ul>

                    </section>

                    <section id="section4">
                        <h2>4&rpar; Καταστροφέας</h2>
                        <p>
                            Kαταστροφέας είναι μια μέθοδος που καλείται όταν ένα αντικείμενο καταστραφεί είτε από το πρόγραμμα αυτόματα είτε από κάποια εντολή delete.
                            Χρησιμοποιείται συχνά για την αποδέσμευση μνήμης.
                        </p>

                        <p>
                            Ο καταστροφέας σε μία κλάση έχει (όπως στους κατασκευαστές) ως όνομα το όνομα της κλάσης και το ειδικό χαρακτηρά '~' μπροστά.
                            Στο κάτω παράδειγμα έχουμε έναν default καταστροφέα που θα κληθεί αυτόματα όταν ένα αντικείμενο δε χρειάζετε πια στο πρόγραμμα, για παράδειγμα 
                            ένα αντικείμενο που έχει εμβάλεια μέσα στην main() τότε θα καταστραφεί αυτόματα στο τέλος του προγράμματος, αντίστοιχα αν έχει δημιουργηθεί σε μια 
                            συνάρτηση και έχει εκεί τοπική εμβέλεια τότε καταστρέφεται όταν τελειώσει η εκτέλεση της συνάρτησης. 
                        </p>

                        <p>
                            Παράδειγμα κώδικα:
                        </p>

                        <pre>
                            <code>
                                class MyClass {
                                    private:
                                        int data;
                                    public:
                                        MyClass() {
                                            data = 0;
                                        }
                                        ~MyClass() {//default καταστροφέας
                                            cout &lt;&lt;"Destructing..."
                                           //καταστροφή αντικειμένου...
                                        }
                                    };

                                    int main(){
                                        myClass obj1;
                                        //χρήση του αντικειμένου...
                                        return 0;//στο τέλος καλείτε ο καταστροφέας του και καταστρέφει το αντικείμενο εφόσον δεν χρειάζετε
                                        //πια η μνήμη του
                                    }
                            </code>
                        </pre>

                        <p>
                            Στην πραγματικότητα δεν χρειάζετε για απλές μεταβλητές καταστροφέας αφού υπάρχει ο 'garbage collector' που στο τέλος του κάθε προγράμματος
                            αποδεσμέυει την μνήμη από μεταβλητές,κανονικούς πίνακες,αντικείμενα και τις κανονικές μεταβλητές του ή απλούς πίνακες.
                            Στην περίπτωση της δυναμικής δέσμευσης μνήμης όμως σε δείκτη χρειάζετε ειδική μεταχείριση.
                        </p>

                        <pre>
                            <code>
                                class MyClass {
                                    private:
                                        int* data;
                                    public:
                                        MyClass() {//κατασκευαστής που κάνει δυναμική δέσμευση μνήμης
                                            if (!data) 
                                                cout &lt;&lt;"Σφάλμα κατά τη δέσμευση μνήμης";
                                            data = new int;
                                            
                                        }
                                        ~MyClass() {
                                            delete data;//δυναμική αποδέσμευση μνήμης στον καταστροφέα
                                        }
                                    };

                                    int main(){
                                        myClass obj1;
                                        //χρήση του αντικειμένου...
                                        return 0;
                                       
                                    }

                                    
                            </code>
                        </pre>

                        <p>
                            Στο πάνω παράδειγμα δημιουργείτε το αντικείμενο και στο δεδομένο μέλος της, int* data, γίνετε δυναμική δέσμευση μνήμης για έναν ακέραιο
                            με new (θα μπορούσε να είναι και για περισσότερες θέσεις μνήμεις με new[size] και αποδέσμευση με delete[]). Αντίστοιχα, για αυτό το λόγο γίνετε στον καταστροφέα δυναμική αποδέσμευση μνήμης του int* data πάλι μετά το πέρας της εκτέλεσης 
                            της main() καλώντας αυτόματα τον καταστροφέα.Αυτός είναι ένας από τους λόγους χρήσης ενός καταστροφέα.
                        </p>

                        <p>
                            Ένας τελευταίος τρόπος χρήσης του καταστροφέα φαίνεται στο κάτω παράδειγμα. 
                        </p>

                        <p>Παράδειγμα:</p>

                        <pre>
                            <code>
                                class MyClass {
                                    private:
                                        int* data;
                                    public:    
                                        MyClass(int x) {//κατασκευαστής που κάνει δυναμική δέσμευση μνήμης
                                            data = x;
                                            
                                        }
                                        ~MyClass() {
                                            cout &lt;&lt;"Destructing..."
                                        }
                                    };

                                int main(){ 
                                    myClass *p = NULL;
                                    p = new myClass(5); 
                                    if (!p) 
                                        cout &lt;&lt;"Σφάλμα κατά τη δέσμευση μνήμης";
                                        //χρήση του p
                                        //...
                                    delete p; //καταστροφή

                                    //εδώ ίσως έχει και άλλες εντολές πριν το τέλος της main()

                                    return 0;
                                }
                            </code>
                        </pre>

                        <p>
                            Στην main() δημιουργείτε ένας δείκτης της κλάσης myClass με αρχικοποίηση σε NULL , άρα χωρίς να δείχνει αρχικά σε κάποιο αντικέιμενο.
                            Μετά δεσμεύετε δυναμικά μνήμη για αντικείμενο της κλάσης myClass με τιμή 5 που θα δωθεί στο όρισμα x του κατασκευαστή.
                            δημιουργείται λοιπόν αντικείμενο καλόντας τον κατασκευαστή με το x=5. Στον κατασκευαστή το δεδομένο μέλος data παίρνει την τιμή του x , 
                            data = 5. Σε αυτό το αντικείμενο τώρα δείχνει ο δείκτης p.Στην εντολή delete p; γίνετε αποδέσμευση της μνήμης του p καλόντας τον καταστροφέα επίσης
                            αυτόματα, σε αυτή την περίπτωση ίσως και πριν την εκτέλεση όλης της main() ή μπορεί να γίνει και στο τέλος αν δεν υπάρχει κάτι ανάμεσα.
                            Αυτός και ο τρόπος κλήσης καταστροφέα πριν το πέρας μιας συνάρτησης ή της main() ανάλογα με το που έχει εμβέλεια/που δημιουγήθηκε το αντικείμενο.

                        </p>


                       
                    </section>

                    <section id="section5">
                        <h2>5&rpar; Υπερφόρτωση τελεστών</h2>

                        <p>
                            Η C++ επιτρέπει την υπερφόρτωση των τελεστών για τα αντικείμενα, δηλαδή τη δημιουργία προσαρμοσμένης συμπεριφοράς 
                            για τους διαφόρων ειδών τελεστές (αριθμητικούς όπως +, -, *, /, σχεσιακοί όπως == κ.λπ.) σε σχέση με τα αντικείμενα της κλάσης.
                            Χωρίς την υπερφόρτωσή τους οι τελεστές δεν λειτουργούν με δικούς μας ορισμούς κλάσεων παρά μόνο με κανονικούς τύπους δεδομένων(premitive)
                            (όπως int) ή με κλάσεις που υπάρχουν ήδη όπως για παράδειγμα η κλάση string.
                            Για να υπερφορτώσουμε έναν τελεστή τότε πρέπει να 'δηλώσουμε μια μέθοδο' με σώμα με τα εξής στο όνομα της: πρώτα το όνομα της
                            κλάσης όπως στους κατασκευαστές και καταστρέφεις και αμέσως μετά την λέξη-κλειδί 'operator' και δίπλα κολλητά τον τελεστή, δηλαδή operator+ για παράδειγμα
                        </p>

                        <p>
                            όλο μαζί: myClass operator+([ορίσματα]) στις παρενθέσεις μπαίνουν πιθανά ορίσματα.
                        </p>

                        <p>
                            Κάτω έχουμε ένα παράδειγμα υπερφόρτωσης του τελεστή της πρόσθεσης '+':
                        </p>

                        <pre>
                            <code>
                                #include &lt;iostream&lt;

                                    class Complex {
                                    private:
                                        double real;
                                        double imaginary;
                                    
                                    public:
                                        Complex(){
                                            real = 0;
                                            imaginary = 0;
                                    }
                                    Complex(double r ,double i){
                                        real = r;
                                        imaginary = i;
                                    }
                                    
                                        // Υπερφόρτωση του τελεστή + για πρόσθεση Complex αριθμών
                                        Complex operator+(const Complex& other){
                                            Complex res;
                                            res.real = real + other.real;
                                            res.imaginary = imaginary + other.imaginary;
                                            return res;
                                        }
                                    
                                        // Συνάρτηση για εμφάνιση του Complex αριθμού
                                        void display() const {
                                            std::cout &lt;&lt; real &lt;&lt; " + " &lt;&lt; imaginary &lt;&lt; "i" &lt;&lt; std::endl;
                                        }
                                    };
                                    
                                    int main() {
                                        Complex complex1(3.0, 4.0);
                                        Complex complex2(1.0, 2.0);
                                    
                                        Complex sum = complex1 + complex2;
                                    
                                        std::cout &lt;&lt; "Αποτέλεσμα της πρόσθεσης: ";
                                        sum.display();
                                    
                                        return 0;
                                    }
                                    
                            </code>
                        </pre>

                        <p>
                            Στο πάνω παράδειγμα δημιουργούνται δύο αντικείμενα της κλάσης Complex (μιγαδικοί αριθμοί , 3.0+4.0i και 1.0+2.0i).
                            Ξέρουμε πως το άθροισμα δύο μιγαδικών γίνετε ως εξής: (a+bi) + (c+di) = a+c + bi+di = (a+c)+(bi+di) = (a+c)+(b+d)i.
                            Ο πρώτος πραγματικός αριθμός είναι το πραγματικό μέρος του και αυτός δίπλα στο i(φανταστική μονάδα)ονομάζετε φανταστικό μέρος 
                            του μιγαδικού.Για την πρόσθεση τους όπως είδαμε απλά προσθέτονται τα πραγματικά μέρη και τα μιγαδικά μέρη ξεχωριστά , το άθροισμα
                            των δύο πραγματικών μερών θα είναι το πραγματικό μέρος του νέου μιγαδικού και το άθροισμα των μιγαδικών μερών το αντίστοιχο νέο μιγαδικό.
                            Προσθέτουμε λοιπόν τα δύο αντικείμενα μιγαδικών με τον υπερφωρτομένο τελεστή '+' όπως είπαμε πιο πάνω και αυτό που εμφανίζει η μέθοδος display()
                            είναι: "Αποτέλεσμα της πρόσθεσης: 4+6i"
                        </p>
                    </section>

                    <section id="section6">
                        <h2>6&rpar; Κληρονομικότητα</h2>

                        <p>
                            Το χαρακτηριστικό της κληρονομικότητας επιτρέπει τη δημιουργία αντικειμένων ως παραγώγων άλλων αντικειμένων.
                            Αποτέλεσμα μιας τέτοιας ενέργειας είναι ότι τα παραγώμενα αντικείμενα μπορούν να συμπεριλαμβάνουν κάποια από τα μέλη των βασικών αντικειμένων,
                            και επιπλέον να ορίζουν και δικά τους μέλη.
                            Το χαρακτηριστικό αυτό αξιοποιείται στις περιπτώσεις όπου κάποια αντικείμενα έχουν βασικά κοινά χαρακτηριστικά.  
                        </p>

                        <p>
                            Η κλάση που παράγεται από μια άλλη κλάση κληρονομεί όλα τα ορατά μέλη της βασικής κλάσης.
                            Για να δημιουργήσουμε μια παράγωγη κλάση χρησιμοποιούμε τον τελεστή ':' στη δήλωσή της
                            <strong>class derived_class_name: public base_class_name;</strong>
                            Όταν δημιουργούμε μια παράγωγη κλάση, τα protected μέλη της βασικής κλάσης μπορούν να χρησιμοποιηθούν από άλλα μέλη της παράγωγης κλάσης.
                            Τα private μέλη, δεν μπορούν.

                        </p>

                        <p>
                            Παράδειγμα:
                        </p>

                        <pre>
                            <code>
                                #include &lt;iostream&gt;

                                    class Polygon {
                                      protected:
                                        int width, height;
                                      public:
                                        void set_values (int a, int b)//setter αντί για κατασκευαστή
                                          { width=a; height=b;}
                                      };

                                    class Rectangle: public Polygon {
                                      public:
                                        int area (void)
                                          { return (width * height); }
                                      };

                                      class Triangle: public Polygon {
                                        public:
                                          int area (void)
                                            { return (width * height / 2); }
                                        };

                                      int main () {
                                        Rectangle rect;
                                        Triangle trgl;
                                        rect.set_values (4,5);
                                        trgl.set_values (4,5); 
                                        std::cout &lt;&lt; rect.area() &lt;&lt; " ";
                                        std::cout &lt;&lt; trgl.area() &lt;&lt; std::endl;
                                        return 0;
                                      }
                            </code>
                        </pre>

                    <p>
                        Αρχικά στην main() βλέπουμε πως δημιουργούνται αυτόματα χωρίς καθορισμένου κατασκευαστή (με κάποιες τιμές που έχουν στη μνήμη, σκουπίδια δηλαδή αλλά
                        δεν μας πειράζει εφόσον θα τις αλλάξουμε στη συνέχεια).
                        Ακριβώς μετά καλείτε η set_values() και στα δύο αντικείμενα και τα αρχικοποιεί πραγματικά σε τιμές  width=4, height=5 και στα δύο.
                        Οι δύο derived κλάσεις(Rectangle,Triangle) δεν έχουν δικιά τους set_values() συναρτήση αλλά κληρονομούν και χρησιμοποιούν αυτή της βασικής κλάσης Polygon. 
                        Επίσης για να χρησιμοποιήσουν την set_values() πρέπει να έχουν και τα δεδομένα μέλη width,height που δε τα έχουν αλλά επίσης κληρονομούν από την βασική κλάση εφόσον 
                        είναι protected. Στο τέλος λοιπόν μπορούν και υπολογίζουν τα εμβαδά τους με τα width,height.
                        Τα εμβαδά που εμφανίζονται είναι: 20 10
                    </p>
                    </section>
                    <section id="section6">
                        <h2>7&rpar; Πολυμορφισμός κλάσεων</h2>

                        <p>
                            Στο προηγούμενο κεφάλαιο μιλήσαμε για την έννοια του πολυμορφισμού αλλά μόνο πάνω σε απλές συναρτήσεις.
                            Εκεί είπαμε πως μπορούμε να έχουμε συναρτήσεις με το ίδιο όνομα με μοναδική διαφορά τους τύπους των ορισμάτων τους.
                            Οπότε ανάλογα με τα ορίσματα εκείνα ο μεταγλωττιστής καταλάβεινε ποια συνάρτηση να καλέσει.
                            Ο πάνω τρόπος είναι μέρος του στατικού πολυμορφισμού, στον οποίο επίσης υπάγετε η υπερφόρτωση(overloading) και υποσκέλιση(overriding)  
                            μεθόδων κλάσεων. Επίσης υπάρχει ο δυναμικός πολυμορφισμός που γίνετε με χρήση virtual(εικονικές) μεθόδους κλάσεων, ένα τέτοιο παράδειγμα
                            έχουμε παρακάτω.
                        </p>

                        <p>
                            Παράδειγμα:
                        </p>

                        <pre>
                            <code>
                                #include &lt;iostream&gt;

                                    // Βασική κλάση
                                    class Shape {
                                    public:
                                        virtual void draw() { 
                                            std::cout &lt;&lt; "Σχήμα" &lt;&lt; std::endl;
                                        }
                                    };
                                    
                                    // Υποκλάση 1
                                    class Circle : public Shape {
                                    public:
                                        void draw(){
                                            std::cout &lt;&lt; "Κύκλος" &lt;&lt; std::endl;
                                        }
                                    };
                                    
                                    // Υποκλάση 2
                                    class Square : public Shape {
                                    public:
                                        void draw(){
                                            std::cout &lt;&lt; "Τετράγωνο" &lt;&lt; std::endl;
                                        }
                                    };
                                    
                                    int main() {
                                        Shape* shapes[2];
                                        Circle circle;
                                        Square square;
                                    
                                        shapes[0] = &amp;circle;
                                        shapes[1] = &amp;square;
                                    
                                        for (int i = 0; i &lt; 2; i++) {
                                            shapes[i]-&gt;draw();
                                        }
                                    
                                        return 0;
                                    }
                            </code>
                        </pre>

                        <p>
                            Στο πάνω παράδειγμα στην main() δημιουργείτε ένας πίνακας δύο στοιχείων τύπου Shape* (δείκτης σε αντικείμενο τύπου Shape).
                            Επίσης δημιουργούνται ένα αντικέιμενο τύπου Circle, circle και ένα τύπου Square, square.
                            Στη συνέχεια η διευθύνση του circle εκχωρείτε στο shape[0] και του square στο shape[1], αυτό θα πει πως
                            το shape[0] δείχνει στο circle και το shape[1] δείχνει στο square.Κατά την επανάληψη for o καθένας από τους δύο δείκτες 
                            καλεί την συνάρτηση draw η οποία υπάρχει στην βασική κλάση shape και στις άλλες με διαφορετικό σώμα σε καθεμία.
                            Σε αυτή την περίπτωση κατά την εκτέλεση το πρόγραμμα αποφασίζει ποια να καλέσει.Αν ο δείκτης σε Shape αντικείμενο δείχνει
                            στο circle τότε καλείτε η draw() της Circle και αν δείχνει στο square τότε της Square αντίστοιχα.
                            Αυτο συμβαίνει αφού οι κλάσεις Circle και Square κληρονομούν από την Shape (βασικά μόνο την εικονική draw()) και επειδή 
                            η draw() στην βασική κλάση Shape είναι virtual(εικονική).
                        </p>
                    </section>
                </div>
            </div>
        </div>

    </main>

    <footer>
        <!--
            <ul id="chapter-end-menu">
                <li><a href="../chapter4/chapter4.html">&larr; Προηγούμενο Κεφάλαιο</a></li>
                <li><a href="../main_menu.php">Αρχικό Μενού</a></li>
                <li><a>Επόμενο Κεφάλαιο &rarr;</a></li>
            </ul>
        -->
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <div class="container collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav mr-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../chapter4/chapter4.html">Προηγούμενο Κεφάλαιο</a>
                    </li>
                </ul>
                <ul class="navbar-nav mx-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../main_menu.php">Αρχικό Μενού</a>
                    </li>
                </ul>
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item" id="last_chap">
                        <a class="nav-link disabled">Επόμενο Κεφάλαιο</a>

                    </li>
                </ul>
            </div>
        </nav>
    </footer>

    <script src="../javascript/disconnect-button.js" type="text/javascript"></script>
    <script src="../javascript/bootstrap-js/bootstrap.js"  type="text/javascript"></script>

</body>

</html>